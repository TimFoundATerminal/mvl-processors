\documentclass[11pt, twoside]{report}

\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}
\usepackage{glossaries}
\makeglossaries

\usepackage{graphicx, listings, xcolor, colortbl, amssymb, adjustbox, csquotes}
\usepackage{baththesis}
\usepackage[nottoc]{tocbibind}
\usepackage{multirow}
\usepackage{makecell}

% Set up Verilog syntax highlighting and style
\lstdefinelanguage{Verilog}{
  keywords={module, endmodule, input, output, wire, assign, integer},
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!60!black}\itshape,
  stringstyle=\color{red},
  morecomment=[l]{//},
  morestring=[b]",
}

\lstset{
  language=Verilog,
  frame=single,
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false,
  tabsize=2
}

\addbibresource{references.bib}

\newacronym{hdl}{HDL}{Hardware Definition Language}
\newacronym{udp}{UDP}{User-Defined Primitives}
\newacronym{mvl}{MVL}{Multi-Valued Logic}
\newacronym{lst}{LST}{Least Significant Trit}
\newacronym{tfa}{TFA}{Ternary Full Adder}
\newacronym{cnt}{CNT}{Carbon Nanotube}
\newacronym{cnfet}{CNFET}{Carbon Nanotube Field-Effect Transistors}
\newacronym{gnfet}{GNFET}{Graphe Nanoribbon Field-Effect Transistors}
\newacronym{cmos}{CMOS}{Complementary Metal-Oxide-Semiconductor}
\newacronym{mosfet}{MOSFET}{Metal-Oxide-Semiconductor Field-Effect Transistor}
\newacronym{finfet}{FinFET}{Fin Field-Effect Transistor}
\newacronym{ttl}{TTL}{Transistor-Transistor Logic}
\newacronym{tmux}{TMUX}{Ternary Multiplexer}
\newacronym{pti}{PTI}{Positive Ternary Inverter}
\newacronym{nti}{NTI}{Negative Ternary Inverter}

% ------------ Config Above here ---------------- %

\title{A Comparative Analysis of Binary vs. Ternary Logic within an Emulated System}
\author{Thomas Timmons}
\degree{Bachelors of Computer Science}
\degreemonthyear{April 2025}
\department{Department of Computer Science}
\faculty{Faculty of Computer Science}

\begin{document}

\maketitle

% \section*{Definitions}

% \printglossary[type=\acronymtype,title=List of Abbreviations]
\begin{abstract}
We present the design and implementation of two comparable digital systems—one using conventional binary logic and another using ternary logic—with comprehensive testbenches enabling identical code execution across both platforms. Despite the theoretical 58\% increase in information density offered by ternary logic, our empirical results reveal no significant performance advantages in practice. The overhead of converting between number systems, increased circuit complexity, and challenges in signal discrimination effectively neutralize the information density benefits. These findings suggest that the research into practical implementations of ternary logic systems have a hard limit unless significant hardware performance can be unlocked to overcome it's binary cousin.
\end{abstract}

\tableofcontents

% \printglossaries

\chapter{Introduction}

For over half a century, Moore's Law has been guiding the semiconductor industry through an exponential increase in performance over time \cite{moore1965cramming}. The current state of the art CMOS technology is now facing fundamental physical limitations due to atomic scaling challenges. With Moore's law predicted to end during this decade \cite{zhou2020quantum}, researchers are exploring alternative approaches to continue developing computing performance to meet the rising demands of tomorrow.

\section{Bringing Back Ternary}

Multi-valued logic (MVL) has emerged as a promising avenue to overcome the limitations of conventional binary systems. Theoretical analysis reveals that the optimal base for number representation is Euler's number $e \approx 2.718$ \cite{bitra2018implementation}. This optimization balances the trade-off between information density and implementation complexity. Since an integer is required for practical implementation of a radix, base 3 is naturally a better approximation making ternary logic theoretically more efficient than binary logic. A ternary system can represent the same information with approximately $63.1\%$ of the digits required by a binary system, potentially offering significant improvements in circuit density, reducing interconnections, and computational efficiency \cite{kim2020logic}.\\
\\
In practice, implementing ternary logic systems requires overcoming substantial challenges in hardware design. While CMOS technology has been optimised for binary logic over decades, it presents limitations for multi-state logic implementation. Carbon Nanotube Field Effect Transistors (CNFETs) have emerged as a promising candidate to support ternary logic, offering superior properties including better threshold voltage regulation, reduced current leakage, and improved switching characteristics compared to conventional CMOS technology.\\
\\
Despite theoretical advantages and promising hardware developments, there remains a critical question: Can ternary logic systems deliver practical performance benefits that justify the transition from well-established binary architectures? This paper addresses this question by designing and emulating comparable binary and ternary computational systems, enabling identical code execution across both platforms. Using empirical values for current CMOS and CNFET technology performance, projections can be made for the crossover needed for CNFET-based ternary systems to outperform binary CMOS systems in circuit density and computational efficiency.\\
\\
Our research aims to quantify the theoretical 58\% increase in information density offered by ternary logic and determine whether this translates to real-world performance advantages. By implementing these systems empirically, we provide insight into whether the pursuit of ternary computing represents a viable path forward in the post-Moore's Law era. These findings have significant implications for determining whether CNFET technology and ternary algebra merit continued research investment as potential successors to binary CMOS computing paradigms.

\section{Key Contributions}

\begin{itemize}
    \item Designed and implemented functionally equivalent binary and ternary processors with matching instruction sets, enabling direct performance comparison through identical code execution across both platforms.
    \item Conducted a comparison between binary and ternary logic systems using empirical data from contemporary CMOS and CNFET implementations, providing a quantitative assessment of the theoretical $58\%$ information density advantage against practical implementation constraints.
    \item Developed a novel implementation of a ternary CONS gates using primitive gates that can be constructed directly from CNFETs, with verified truth tables and propagation delay calculations that extend the existing literature on ternary logic circuits.
    \item Created a standardised methodology for expressing ternary logic complexity in terms of CNFET components and propagation delay, establishing a comparable metric to the well-established CMOS count used in binary circuit analysis.
    \item Engineered a digital test platform that can serve as an ongoing benchmark to monitor advancements in both CNFET and CMOS gate designs, providing a consistent baseline for evaluating the evolving state of performance between binary and ternary technologies.
\end{itemize} 

\chapter{Ternary Algebra}

\section{A Case for Computing in Ternary}

The cost or complexity of number systems can be evaluated through representation efficiency, computational overhead, and implementation requirements.\\
\\
Representation efficiency refers to how many digits or symbols are required represent any given range of values $N$, with the base of the number system represented by $R$ and the necessary number of digits required is $d$ (rounded upwards to the nearest integer):
\begin{equation*}
  \label{eq:1}
  N = R^{d}
\end{equation*}
This directly impacts the memory usage and storage costs in a computing system.\\
\\
The computational overhead involves the complexity of performing basic arithmetic operations. Larger bases require the management of more states, requiring the 
processing of a larger set of possible combinations. The number of possible combinations is given by:
\begin{equation*}
  C = R^{i}
\end{equation*}
Where $i$ is the number of inputs for the operation and $R$ is the base of the number system as defined before. For example, the number of possible combinations 
for addition is $C = R^{2}$ which in binary is $C = 2^{2} = 4$ creating the set $\{0+0, 0+1, 1+0, 1+1\}$. 
In ternary the set would be $C = 3^{2} = \{0+0, 0+1, 0+2, 1+0, 1+1, 1+2, 2+0, 2+1, 2+2\} = 9$ which requires implementing more logic circuits to handle the 
additional combinations.\\
\\
When considering the representation efficiency of a number system, looking at the formula's you would assume that increasing the base would increase the efficiency but the more digits also require more space. Therefore we make the assumption that $c$ is directly proportional to the capacity of the digits $(R \cdot d)$.
(Hurst also discusses the cost assuming that the cost is independent of the radix $R$ which would lead us to believe that the larger the base the more efficient the system.)\\
\\
Therefore for some constants $k$ to represent the direct proportionality we can substitute $d = \frac{\log N}{\log R}$ from Equation \ref{eq:1} into 
the formula \cite{hurst1984mvl}:
\begin{equation*}
  c = k(R \cdot d) = k \left( R \cdot \frac{\log N}{\log R} \right) = k \log N \left(\frac{R}{\log R}\right)
\end{equation*}
Minimising this cost $c$ can be done by differentiating with respect to $R$ and setting the result to $0$:
\begin{equation*}
  \frac{\partial c}{\partial R} = 
  k\log N\cdot\frac{d}{dR}\left[\frac{R}{\log R}\right] = 
  k\log N\cdot \frac{\log R -1}{(\log R)^2} = 0
\end{equation*}
After removing constants $\log R = 1$ and solving for $R = e = 2.718$. This work by Hurst in 1984 at the University 
of Bath shows that the natural base is the most efficient radix for implementation of switching circuits \cite{bitra2018implementation}.
Since as stated in Equation \ref{eq:1}, the radix $R$ must be an 
integer then we are left with $R = 3$ to be able to perform computation \cite{jaber2020mvl}.

\section{Balanced vs. Unbalanced}

In binary logic, the set of possible values is denoted as $\mathbb{B} = \{0, 1\}$ with no opportunity for symmetry due to having a even base. Ternary numeral systems however can either be balanced or unbalanced where negative numbers can be considered part of the base. Unbalanced ternary values are most commonly denoted using $\mathbb{T} = \{0, 1, 2\}$  whereas balanced ternary values represent $\mathbb{T} = \{-1, 0, 1\}$ with a variety of glyphs used in place of $-1$ such as $\overline{1}$ or $T$.\\
\\
Balanced ternary has the elegant property that of representing negative numbers intrinsically without the need for a 
separate signed bit. This leads to more symmetric carry rules due to a more even distribution around zero as shown in 
Figure \ref{fig:ternary_ops}.\\

\begin{figure}[h]
    \centering
    \begin{minipage}{0.22\textwidth}
        \centering   
        \begin{tabular}{|c||c|c|c|}
            \hline
            $+$ & $T$ & $0$ & $1$ \\
            \hline\hline
            $T$ & $T1$ & $T$ & $0$ \\
            \hline
            $0$ & $T$ & $0$ & $1$ \\
            \hline
            $1$ & $0$ & $1$ & $1T$ \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.22\textwidth}
        \centering   
        \begin{tabular}{|c||c|c|c|}
            \hline
            $-$ & $T$ & $0$ & $1$ \\
            \hline\hline
            $T$ & $0$ & $T$ & \textbf{$T1$} \\
            \hline
            $0$ & $1$ & $0$ & $T$ \\
            \hline
            $1$ & \textbf{$1T$} & $1$ & $0$ \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.22\textwidth}
        \centering   
        \begin{tabular}{|c||c|c|c|}
            \hline
            $\times$ & $T$ & $0$ & $1$ \\
            \hline\hline
            $T$ & $1$ & $0$ & $T$ \\
            \hline
            $0$ & $0$ & $0$ & $0$ \\
            \hline
            $1$ & $T$ & $0$ & $1$ \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.22\textwidth}
        \centering   
        \begin{tabular}{|c||c|c|c|}
            \hline
            $\div$ & $T$ & $1$ \\
            \hline\hline
            $T$ & $1$ & $T$ \\
            \hline
            $0$ & $0$ & $0$ \\
            \hline
            $1$ & $T$ & $1$ \\
            \hline
        \end{tabular}
    \end{minipage}
    \caption{Balanced Ternary Single-Trit Addition, Subtraction, Multiplication and Division Tables}
    \label{fig:ternary_ops}
\end{figure}
For subtraction and division which are not commutative, the first operand is given to the left of the table and the second at the top.\\
\\
Balanced ternary has a range of advantages when it comes to computation over binary logic such as the reduction in the carry rate for 
addition/subtraction cuts down the carry rate in multi-digit multiplication as demonstrated in Figure \ref{fig:ternary_ops} with 
the values being $2/9$ and $1/4$ respectively. Also notice that it is possible to perform subtraction by negating the second operand and 
adding the two values together which will useful for the implementation of the ternary logic gates.\\
\\
Therefore, for this paper and emulator we will be using balanced ternary logic and any mention of `ternary logic` is referring to 
`balanced ternary logic`.\\
\\
To calculate the value of a ternary number $T$ with a radix point in decimal we can use the following formula:\\
\begin{equation*}
    v = (a_{n}a_{n-1} \dotsb a_{0}.c_{1}c_{2}c_{3} \dotsb)_3 = \sum_{i=0}^{n} a_{i} 3^{i} + \sum_{i=1}^{\infty} c_{i} 3^{-i}
\end{equation*}
Where $n$ and $m$ are the number of digits to the left and right of the radix point respectively and $v$ is the value in decimal given 
a vector of values containing a radix point. Notice that each position can have a negative contribution to the total due 
to $a,c \in \{ -1, 0, 1 \}$. The symmetry creates the elegant property where negation can be performed by negating each 
trit within the word which has the benefits of only needing an addition circuit as mentioned above.

\section{Binary to Ternary and Back}

To directly compare between the binary and ternary systems we need to consider how we can encode binary values into ternary values and 
vice versa. Using continued fractions, the best approximations to rationals are given by convergents to the continued fraction, 
alternating between overshooting and undershooting the target value \cite{davenport2008arithmetic}.\\
\\
Since we are looking for $2^{a} \approx 3^{b}$ where $a,b \in \mathbb{N}$. We can take the logarithm of both sides to get the following:
\begin{equation*}
    \frac{a}{b} \approx \frac{\log 3}{\log 2}
\end{equation*}
Where $2^{a} < 3^{b}$ to ensure that the binary value can be encoded into a ternary value.\\
\\
This continued fraction expansion can be calculated by computing the convergents which are as follows:
\begin{equation*}
    \frac{\log 3}{\log 2} = a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \frac{1}{a_3 + \dotsb}}}
\end{equation*}
\begin{equation*}
    {a_0; a_1, a_2, a_3, a_4 \dotsb} = {1; 1, 1, 2, 2, \dotsb}
\end{equation*}
This gives us:
\begin{align*}
    \frac{2}{1} &= 1 + \frac{1}{1} \Rightarrow 2^{2} \approx 3^{1} \text {  } (\text{but ternary worse than binary: } 2^{2} > 3^{1})\\
    \frac{3}{2} &= 1 + \frac{1}{1 + \frac{1}{1}} \Rightarrow 2^{3} \approx 3^{2} \\
    \frac{8}{5} &= 1 + \frac{1}{1 + \frac{1}{1 + \frac{1}{1}}} \Rightarrow 2^{8} \approx 3^{5} \text {  } (\text{but ternary worse than binary: } 2^{8} > 3^{5})\\
    \frac{19}{12} &= 1 + \frac{1}{1 + \frac{1}{1 + \frac{1}{1 + \frac{1}{2}}}} \Rightarrow 2^{19} \approx 3^{12}
\end{align*}

$\frac{19}{12}$ provides a good approximation with an efficiency of 98.65\%. However using a 19 bit word is not practical due to it being too large.\\
\\
$\frac{11}{7}$ also provides a good approximation with an efficiency of 93.64\%. This is created by summing the 2nd and 3rd convergents
$\frac{3+8}{2+5}$ which provides a good balance between efficiency and word size.\\
\\
This is the same ratio that Micron uses to encode 11 bits of binary data into 7 trits in their GDDR7 memory bus using PAM3 \cite{micron2024gddr7}.\\
For our emulator we will use the same ratio in an attempt to simulate the performance potential of running this bus directly into a ternary ALU.

\section{Ternary Logic Gates}

Gates can be represented in matrix form where the following Binary AND truth table has the has the equivalent matrix representation:\\
\begin{figure}[h]
    \centering
    \begin{minipage}{0.2\textwidth}
        \centering   
        \begin{tabular}{|c||c|c|}
            \hline
            $A \times B$ & $0$ & $1$ \\
            \hline\hline
            $0$ & $0$ & $0$ \\
            \hline
            $1$ & $0$ & $1$ \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \centering   
        $\begin{bmatrix}
            0 & 0 \\
            0 & 1 \\
        \end{bmatrix}$
    \end{minipage}
    \caption{Binary AND Gate Truth Table and Matrix Representation}
    \label{fig:matrix_notation}
\end{figure}

\subsection{Single-Input Gates}

Single-input gates can be represented as a vector of length $2$ for binary logic and length $3$ for ternary logic. Combination theory 
shows that the number of possible combinations for a single input gate is $n^{n}$ where $n$ is the number of inputs. Therefore, the 
number of possible combinations for a single input gate is $2^{2} = 4$ and $3^3 = 9$ for binary and ternary logic gates. Most of these 
are redundant so only the useful gates have been listed in Figure \ref{fig:single_value_bin_gates} and \ref{fig:single_value_tern_gates}.\\

\begin{figure}[h]
    \centering
    \begin{tabular}{c|c|c|c}
        Matrix & Description & Name & Symbol \\
        \hline
        $\begin{bmatrix}0 \\ 1 \\\end{bmatrix}$ & Identity, Buffer, Pass & Buffer & $A$ \\
        $\begin{bmatrix}1 \\ 0 \\\end{bmatrix}$ & Inverter & NOT & $\overline{A}$ \\
    \end{tabular}
    \caption{Useful Single Value Binary Gates}
    \label{fig:single_value_bin_gates}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tabular}{c|c|c|c}
        Matrix & Description & Name & Symbol \\
        \hline
        $\begin{bmatrix}T \\ 0 \\ 1 \\\end{bmatrix}$ & Identity, Buffer, Pass & BUF & $A$ \\
        $\begin{bmatrix}1 \\ 0 \\ T \\\end{bmatrix}$ & Inverter & NOT & $\overline{A}$ \\
        $\begin{bmatrix}1 \\ 1 \\ T \\\end{bmatrix}$ & Positively Biased Inverter & PTI & $\hat{A}$ \\
        $\begin{bmatrix}1 \\ T \\ T \\\end{bmatrix}$ & Negatively Biased Inverter & NTI & $\check{A}$ \\
        % $\begin{bmatrix}1 \\ 0 \\ 1 \\\end{bmatrix}$ & Absolute & ABS & $|A|$ \\
        % $\begin{bmatrix}T \\ 0 \\ 1 \\\end{bmatrix}$ & Increment & INC & $A^{+}$ \\
        % $\begin{bmatrix}T \\ 0 \\ 1 \\\end{bmatrix}$ & Decrement & DEC & $A^{-}$ \\
        % $\begin{bmatrix}T \\ 0 \\ 1 \\\end{bmatrix}$ & Is Positive & ISP & $A^{=+}$ \\
        % $\begin{bmatrix}T \\ 0 \\ 1 \\\end{bmatrix}$ & Is Zero & ISZ & $A^{=0}$ \\
        % $\begin{bmatrix}T \\ 0 \\ 1 \\\end{bmatrix}$ & Is Negative & ISN & $A^{=-}$ \\
    \end{tabular}
    \caption{Useful Single Value Ternary Gates}
    \label{fig:single_value_tern_gates}
\end{figure}

\subsection{Two-Input Gates}

\begin{figure}[h]
    \centering
\begin{tabular}{c|c|c|c}
        Matrix & Description & Name & Symbol \\
        \hline
        $\begin{bmatrix}0 & 0 \\ 0 & 1 \\\end{bmatrix}$ & And & AND & $A \times B$ \\
        $\begin{bmatrix}0 & 1 \\ 1 & 1 \\\end{bmatrix}$ & Or & OR & $A + B$ \\
        $\begin{bmatrix}0 & 1 \\ 1 & 0 \\\end{bmatrix}$ & Exclusive Or & XOR & $A \oplus B$ \\
\end{tabular}
    \caption{Useful Two-Input Binary Gates}
    \label{fig:two_value_bin_gates}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{tabular}{c|c|c|c}
            Matrix & Description & Name & Symbol \\
            \hline
            $\begin{bmatrix}T & T & T \\ T & 0 & 0 \\ T & 0 & 1 \\\end{bmatrix}$ & And/Minimum & AND & $A \times B$ \\
            $\begin{bmatrix}1 & 1 & 1 \\ 1 & 0 & 0 \\ 1 & 0 & T \\\end{bmatrix}$ & Not And & NAND & $A \times B$ \\
            $\begin{bmatrix}T & 0 & 1 \\ 0 & 0 & 1 \\ 1 & 1 & 1 \\\end{bmatrix}$ & Or/Maximum & OR & $A + B$ \\
            $\begin{bmatrix}1 & 0 & T \\ 0 & 0 & T \\ T & T & T \\\end{bmatrix}$ & Not Or & NOR & $A + B$ \\
            $\begin{bmatrix}T & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \\\end{bmatrix}$ & Consensus & CONS & $A \boxtimes B$ \\
            $\begin{bmatrix}T & T & 0 \\ T & 0 & 1 \\ 0 & 1 & 1 \\\end{bmatrix}$ & Any & ANY & $A \boxplus B$ \\
            $\begin{bmatrix}1 & 0 & T \\ 0 & 0 & 0 \\ T & 0 & 1 \\\end{bmatrix}$ & Multiplication & MUL & $A \otimes B$ \\
            $\begin{bmatrix}1 & T & 0 \\ T & 0 & 1 \\ 0 & 1 & T \\\end{bmatrix}$ & Addition & SUM & $A \oplus B$ \\
            $\begin{bmatrix}0 & 1 & 1 \\ T & 0 & 1 \\ T & T & 0 \\\end{bmatrix}$ & Equality & EQ & $A == B$ \\
    \end{tabular}
    \caption{Useful Two-Input Ternary Gates}
    \label{fig:two_value_ter_gates}
\end{figure}

All of the gates in Figure \ref{fig:two_value_bin_gates} and \ref{fig:two_value_ter_gates} have inverted equivalents that can be created by negating the output will be denoted with an N proceeding the gate name. e.g. NAND, NOR, NANY.\\

As shown in figures \ref{fig:single_value_tern_gates}, the critical path of a fundamental gate is directly proportional to the propagation delay $\tau$ for some real constant $k$. For each gate, $k$ is dependent on the specific circuitry arrangement of the underlying components. It is also worth noting the relationship between propagation delay and the system base where binary scales linearly with the number of transistors in the critical path. Ternary however, has a far less linear relationship between transistor count and the propagation delay due to the more complex signal paths required.\\
\\
These gates can be combined to build more complex circuitry such as adders, multipliers and ALU's in their respective bases with a possible implementation shown by \cite{keshavarzian2014novel}.\\

\chapter{Literature and Technology Survey}

\section{A Brief History of Ternary}

Setun was a sequential computer developed in 1958 by Sergei Sobolev and Nikolay Brusentov at Moscow State University. It was the most recent working ternary computer using the balanced ternary numeral system consisting of 81 words of memory where each word was composed of 18 trits. It has a one-address architecture with one index register and was able to handle both positive and negative floating point calculations \cite{weatherby2018ternary} \cite{brousentsov2002development}.\\
\\
The instruction set consisted of 24 instructions including performing mantissa normalisation for floating point calculations,
shift, combined multiplication and addition.
\\
In 1970, the Setun-70 was developed that built on idea of its predecessor. It had a short instruction set that was developed 
and implemented independently from the RISC architecture principles but did implement Dijkstra's ideas of of structured 
programming. Both of these computers where only used for research purposes and were never used commercially. The interval range 
for the mantissa value of a normalised number was changed to $\{0.5 < |m| < 1.5\}$ whereas it had been $\{0.1666... < |m| < 0.5\}$ 
in its predecessor \cite{brousentsov2002development}.\\
\\
During a thawing period of the Cold War, visits were allowed between scientists from the different nations resulting in 
TERNAC. This was an emulator written in FORTRAN by the State University of New York at Buffalo and was able to deliver 
on technical promise of ternary systems. As Setun when implementing the hardware was lacking a switch that could encode 
the two values in one setting and instead used two separate gates \cite{weatherby2018ternary}.\\
\\
Weatherby summarises this history with the following statement:
\begin{displayquote}
    "Ternary computing, in other words, has always been emulation rather than implementation—its history is in large part imaginary."
\end{displayquote}
And while his article is not a scientific paper and is written in a stylised and opinionated manner, it does raise a valid point.  
Fundamentally it may be impossible to implement a true ternary system in hardware due to fundamental laws around digital logic. 
However, we need not concern ourselves as we are only looking at the implications of ternary logic should it be possible 
to implement in hardware.\\
\\
Brousentov takes an opposing point of view in his paper where he argues that the Setun computer did realise the theoretical 
benefits despite the two separate gates \cite{brousentsov2002development}:\\
\begin{displayquote}
    "This experience convincingly confirms practical preferences of ternary digital technique."
\end{displayquote}
This also should be viewed with caution as the paper was written by Russian scientists in 2002 and while it gives a few details on the 
architecture of Setun it does not contain any quantitative measures. It does contain a lot uncited claims with a heavy use of adjectives of 
almost a persuasive nature.\\
\\
A more recent publication by Zahoor et al. in 2024 provides a more favourable view on the possible future of ternary. 
The paper discusses the benefits and possible implementations of ternary logic using novel post-CMOS devices due to advances in 
material science and nanotechnology. It cites several researchers who have reported ternary arithmetic logic unit designs which 
provide increased computation capability along with high energy efficiency and reduced interconnect complexity \cite{zahoor2024design}.\\
\\
One example of these papers from 2009 by Keshavarzian et al. details the design of a ternary full adder (TALU) 
using Carbon Nanotube Field Effect Transistors (CNTFET) to get a $53\%$ increase in Power-Delay Product (PDP) 
at $250$MHz over previous CNTFET designs but does not make a direct comparison to a binary equivalent \cite{keshavarzian2014novel}.

\section{Alterative Uses of Ternary Values}

The use of multiple values has been implemented in industrial solutions due to limitations in bandwidth because of interconnection difficulties. 
This relates to the shoreline problem where if you consider a chip of side length $n$ with a perimeter 
of $4n$ and an area of $n^{2}$. If we double the side length to $2n$ the perimeter becomes $8n$ and the area becomes $4n^{2}$. The perimeter 
has doubled but the area has quadrupled. This also applies to the number of pins on a chip where you begin to run into interconnection 
difficulties \cite{zahoor2024design}. 
Inherently increasing the base of a number system will reduce the demand for bandwidth resulting in a smaller necessary interface area 
due to more information being transmitted per pin \cite{zahoor2024design}.
\\
NVIDIA 30 Series GPU's make use of ternary values to encode 3 different pulse amplitudes on a single wire within the memory bus of their cards 
and will be used in their next generation of GPUs and is currently in development by Micron \cite{micron2024gddr7}.
PAM3 encoding is used to increase the single pin throughput 32Gb/s compared to its predecessor GDDR6 which had a throughput of 18Gb/s. This 
is achieved by encoding the sequential binary values into ternary values represented by 3 different voltage levels. This allows for 3 bits 
of information to be transmitted on a single wire within two clock cycles (1.5 bits per cycle) \cite{micron2024gddr7} \cite{nam2024low}.\\
\\
Non-classical computing provide potential ways to implement ternary logic. One of these is optical computers 
(Photonic Computers), which use light to perform computation using photons. 
Infrared light with a wavelength of $1.50\mu m$ is used to transmit data long distances within optical fibres but 
light with wavelengths around $570nm$ can can be used to perform computation. Logic gates are built using interference 
patterns to define possible states where polarisation provides a way to encode ternary values.\\
\\
This technology is mainly being used to data transfer but interest is growing due to the exponential demand for 
parallel processing with the rise of AI and machine learning.\\

\section{Ternary in Hardware}

Construction of binary microprocessors, microcontrollers, and memory chips are often constructed using CMOS technology. They use a complementary and symmetrical pair of p-type and n-type MOSFETs to create logical functions. Due to one of the MOSFET pair always being switched off, the series combination draws significantly less current while providing a higher noise immunity compared to alternatives such as NMOS logic or Transistor-Transistor logic (TTL) \cite{calebotta1975cmos}. As of 2011, 99\% of IC chips, including most digital, analogue and mixed signals IC's, were fabricated using CMOS technology \cite{voinigescu2013high} and while newer technologies like FinFET are emerging, CMOS remains the most common method of manufacture for binary systems.\\
\\
The design of ternary logic gates naturally requires multi-threshold components. While CMOS technology allows for the implementation of multi-threshold systems, scaling this to nanometres presents manufacturing challenges such as high energy density, current leakage, and interconnect problems \cite{zahoor2024design}. Research now focuses on developing technologies more suited to handling multiple threshold values such as Graphene Nano-ribbon Field Effect Transistors (GNRFETs) and Carbon Nanotube Field Effect Transistors (CNFETs). These have gained popularity within ternary logic circuit designs by using the threshold voltage regulation technique to build arithmetic and logic components \cite{sharma2020energy}.\\

\subsection{CMOS and CNFET Gates}

CNFETs are among the promising candidates to replace CMOS technology toward the 7-nm node and beyond \cite{luo2013compact}. CNFET drivers show significant improvement regarding crosstalk-induced effects from $34\%$-$67\%$ depending on the interconnect lengths ranging from $500\mu m$-$100\mu m$ \cite{hamedani2020comparative}. While this is not a metric we are concerned with in our test bench, it does support the decision for this paper to use CNFET as the state of the art ternary benchmark hardware implementation. All hardware comparisons between bases will then be against CNFET and CMOS technology throughout this paper. Limitations of this will be discussed within our conclusion.\\
\\
Many papers have claimed various propagation delays in picoseconds for their proposed design which have been summarised within the Figure \ref{fig:node-prop-delay}. In 2024, Vidhyadharan et al. performed a direct comparison of hysteresis voltage comparators with CMOS and CNFET achieving $162$ps and $47$ps delays respectively \cite{vidhyadharan2024fast}. However, both comparators require multiple gates to implement the comparators, only giving a rough estimation of relative performance. Luo et al. proposed a semi-empirical model that takes the physical structure and design parameters as inputs and outputs the expected behaviour and side effects of the gate. After optimisation of the ratio of gate, contact, and extension lengths, a value of $0.48$ps$\tau$ and $0.55$ps$\tau$ for $7$nm node and $11$nm node were obtained respectively. While this model is calibrated using experimental results, these are not empirical values and should be treated as such. Anand et al. simulated the performance of both CNFET and CMOS technology at $32$nm nodes using Stanford's MOSFET-like CNFET model \cite{anand2013performance}.\\
\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{figures/cnfet_cmos_scatter.png}
    \caption{Comparison of CNFET and CMOS technology - Node Size vs. Propagation Delay}
    \label{fig:node-prop-delay}
\end{figure}
\\
Figure \ref{fig:node-prop-delay} does not have sufficient data to make any conclusions but in hardware, CNFET is at least as good as CMOS technology in regards to propagation delay when making comparisons for similar gate sizes and architecture.

\subsection{Existing Ternary Gate Designs}

The main advantages of complementary design are robustness, good performance, all with low static power dissipation. CMOS uses the logic design widely but a complementary CNFET network can also be used to good effect by avoiding the use of large resistors to reduce circuit footprint \cite{lin2009cntfet}. As shown in Figure \ref{fig:jaber-ternary-inverter}, CNFETs are not always used complementary and therefore counts will be of each CNFET individually. To ensure a fair comparison to CMOS implementations, these will also be counted individually in Table \ref{tab:gate_characteristics}. The count of the number of gates does not account delay for any changes in state to propagate through the system. For this we will explicately measure the propagation delay of each component with respect to the circuit configuration.\\
\\
Many proposed existing designs focus on using ternary decoders in order to integrate their designs into existing binary systems \cite{tabrizchi2019novel}. As an aside, it's interesting to note that Micron uses ternary encodings for the bus whereas the inverse is being assumed here. As our ternary system will be built entirely from ternary logic, we want to focus on designs that use purely ternary logic to perform arithmetic and logic operations.\\
\\
Jaber et al. proposes designs for a ternary inverters (PTI, STI, NTI) along with a ternary NAND gate requiring 5 and 10 CNFET's respectively \cite{jaber2019high}. Theses designs use dual supply voltages (\textit{VDD}, \textit{VDD/2}) to reduce the number of gates required as shown in the appendix as Figures \ref{fig:jaber-ternary-inverter} and \ref{fig:jaber-ternary-nand}. This cites the work of Lin et al. who proposed a ternary NOR design that requires 10 CNFET's to produce \cite{lin2009cntfet}. Duret contributes a design for a ANY gate using 7 CNFET's when designing a working ternary ALU \cite{duret2019ternaryALU}. Murotiya et al. contributed to the field by proposing a design using 18 CNFET's that although has 4 inputs, duplicating wires allow it be used as two input gate \cite{murotiya2014cntfet}.

\subsection{Proposed Ternary Gate Designs}

NAND and NOR are universal gates in ternary systems and any other logic circuit can be built based on these two gates \cite{paul2021cntfet}. Ideally we would be able to find research that implements CONS and ANY gates directly out of CNFET's but at time of writing no such designs have been proposed.\\
\\
In this paper I propose the following design for ternary CONS gate that can be implemented using fundamental CNFET gates as shown in Figure \ref{fig:consensus-gate-design} where the notation of a plus symbol inside of the inverter represents a PTI.\\
\\
This design has been validated logically using a custom python script with the generated truth table shown in Figure \ref{tab:consensus-truth-table}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{figures/Ternary Consensus Design.drawio.png}
    \caption{Ternary Consensus Gate Design}
    \label{fig:consensus-gate-design}
\end{figure}

\begin{table}[htbp]
  \centering
  \begin{tabular}{c|ccc}
    \hline
    \multirow{2}{*}{Input A} & \multicolumn{3}{c}{Input B} \\
    \cline{2-4}
    & $-$ & $0$ & $+$ \\
    \hline
    $-$ & $-$ & $0$ & $0$ \\
    $0$ & $0$ & $0$ & $0$ \\
    $+$ & $0$ & $0$ & $+$ \\
    \hline
  \end{tabular}
  \caption{Consensus Gate Truth Table}
  \label{tab:consensus-truth-table}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{|c|l|l|c|c|c|}
        \hline
        & Name & Description & \makecell{Transistor\\Count} & \makecell{Propagation\\Delay} & Source \\
        \hline
        \multirow{7}{*}{\rotatebox[origin=c]{90}{\makecell{Binary\\CMOS}}} 
        & NOT & Inverter & 2 & $1.0\tau$ & Fig \ref{fig:cmos-binary-not} \\
        & AND & And & 6 & $3.0\tau$ & Fig \ref{fig:cmos-binary-and} \\
        & NAND & Not And & 6 & $2.0\tau$ & Fig \ref{fig:cmos-binary-nand} \\
        & OR & Or & 6 & $3.0\tau$ & Fig \ref{fig:cmos-or-gate} \\
        & NOR & Not Or & 6 & $2.0\tau$ & Fig \ref{fig:cmos-nor-gate} \\
        & XOR & Exclusive Or & 12 & $4.0\tau$ & Fig \ref{fig:cmos-binary-xor} \\
        \hline
        \multirow{11}{*}{\rotatebox[origin=c]{90}{\makecell{Ternary\\CNFET}}} 
        & NOT & Inverter & 5 & $1.6\eta$ & \cite{jaber2019high} \\
        & PTI & Positively Biased Inverter & 5 & $2.0\eta$ & \cite{jaber2019high} \\
        & NTI & Negatively Biased Inverter & 5 & $2.0\eta$ & \cite{jaber2019high} \\
        & AND & And/Minimum & 15 & $4.6\eta$ & \\
        & NAND & Not And & 10 & $3.0\eta$ & \cite{jaber2019high} \\
        & OR & Or/Maximum & 15 & $6.6\eta$ & \\
        & NOR & Not Or & 10 & $5.0\eta$ & \cite{lin2009cntfet} \\
        & XOR & Exclusive Or & 18 & $6.0\eta$ & \cite{murotiya2014cntfet} \\
        & CONS & Consensus & 55 & $\eta$ & Self \\
        & ANY & Any &  & $\eta$ & \cite{duret2019ternaryALU} \\
        \hline
    \end{tabular}
    \caption{Comprehensive Gate Characteristics}
    \label{tab:gate_characteristics}
\end{table}

The table \ref{tab:gate_characteristics} consolidates findings from various research papers and proposed designs to present a comparative summary of both binary and ternary logic gates implemented in their respective technologies. The table documents the number of individual transistors (CMOS/CNFET) required to construct each logical function, providing a direct measure of circuit complexity and potential area requirements. Propagation delay of the critical path through each gate has also been documented, both are expressed in relative terms of the switching delay of the underlying hardware. $\tau$ is used to denote the switching time of CMOS based technology and $\eta$ is used to denote circuits designed using CNFET technology. Standardising these measurements like this allows flexibility for meaningful comparisons between gates based on theoretical assumptions as well as empirical switching delays for various node sizes. This will be useful during our results section to give context to our findings from our emulator to practical implications.\\
\\
Delay propagation is derived from the circuit design for each individual gate, referenced in the table for fundamental gates, which can be found in the Appendix along with explanations in Table \ref{tab:gate-delay-reasoning}.\\
\\
Over the years all CMOS designs have been standardised but all diagrams in this paper are sourced from All About Electronics \cite{allaboutelectronicsCMOSLogic}. 

\chapter{Emulation of Circuits}

\section{Hardware Definition Languages}

Hardware Description Languages (HDL) are a set of specialised programming languages that are used to define the structure and behaviour of electronic circuits. They enable designers to create, simulate and verify digital hardware. They are often used with in industry as part of the prototyping stage of a product before any physical components are built.\\
\\
Verilog and VHDL are the most popular HDL's with open source offerings that both meet IEEE standards. They differ in details such as syntax but the main distinctions are in their design methodology. Verilog operates on the concept of modules and hierarchy. Modules are the fundamental building blocks that encapsulate functionality and interconnections into a reusable component e.g. a half-adder. These can then be instantiated to create a hierarchy of components e.g the ALU module instantiates a full-adder. VHDL also promotes a hierarchical design approach but instead focuses on entities and architectures. Where entities define the interface for the component and architectures describe their internal behaviour.\\
\\
Both systems provide support for multiple levels of abstraction including behavioural and dataflow but only Verilog allowing for gate-level definitions. This enables designers to describe systems using primitive gates such as AND, OR, and NOT as shown in \ref{fig:verilog-and-gate}. Verilog also allows for user-defined primitives (UDPs) to create custom gate-level components that enable designers to build complex or specialised elements. In order to accurately compare both systems we need to be able to define the system at the gate-level and along with the flexibility to create custom primitives. This will allow for the implementation of ternary logic and components. It would also be possible to use VHDL but given Verilog's ease of use, it naturally lends itself to non-standard applications such as MVL.\\
\\
\begin{figure}
    \centering
    \begin{lstlisting}
    module example_and_gate(
        input_1,
        input_2,
        and_result
    );
      
      input wire input_1;
      input wire input_2;
      output wire and_result;
     
      assign and_result = input_1 & input_2;
     
    endmodule
    \end{lstlisting}
    \caption{Verilog implementation of a binary AND gate.}
    \label{fig:verilog-and-gate}
\end{figure}
Verilog provides testbenches where users can create a separate module that instantiates the design under test and applies stimuli to verify it's logical correctness and timings. Testbenches can be written at the behavioural level, saving designers having to specify their implementation details. Programs can then be loaded and executed in order to perform a variety of benchmarks.\\
\\
It is also an important distinction to make between Verilog and SystemVerilog. SystemVerilog is an extension of Verilog that includes additional features for advanced design and verification. However this is not available open source and therefore this paper will be using base Verilog which will seriously impact our ability to accurate emulate MVL logic systems.

\section{Ternary in Verilog}

An immediate impact of not having access to SystemVerilog, we are forced to approximate these 3 possible voltage levels using two binary bits to encode a single ternary trit. For our balanced ternary representation $\{-1, 0, 1\}$ the following binary encoding scheme for trits is:

\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        \text{Ternary Value} & \text{Notation} & \text{Binary Representation} \\
        \hline
        -1 & \text{\_1} & \text{0b11} \\
        \hline
        0 & \text{\_0} & \text{0b00} \\
        \hline
        1 & \text{\_1\_} & \text{0b01} \\
        \hline
    \end{tabular}
    \label{tab:ternary-trit-encodings}
\end{table}

This encoding scheme allows direct representation of negative numbers by treating each binary encoding as a signed binary integer returns its ternary value, simplifying the complexity of the compiler. Limitations and the steps needed to move to a true ternary system will be discussed in detail within the conclusion. In the context of Verilog, this setup prevents us from obtaining voltage traces for various ternary components to compare against the frequency of voltage changes of their binary counterparts.

\section{Circuit Simulation}

Verilog provides capabilities for simulating digital logic at several levels of abstraction, including gate-level representations. When working at the gate level, Verilog allows for logic verification through testbenches that apply stimulus patterns and observe output responses. For our comparative analysis, this capability allows us to measure the number of gates required to perform any equivalent operations in the respective binary and ternary systems.\\
\\
However, this does not simulate the physical phenomena that occurs in semiconductor implementations including analogue effects such as voltage variations, current leakage, and parasitic capacitance. All of which are important considerations when working in MVL circuits due to their sensitivity around voltage thresholds higher error rates.\\
\\
HSPICE is a specialised simulation tool designed for accurate transistor-level modelling and is flexible enough to simulate both CMOS and CNFET technology. While HSPICE would be able to capture all of these characteristics that Verilog cannot, it is a propriety tool developed by Synopsys and requires a commercial licensing agreement which this paper have has not been the benefit of.\\
\\
Given this limitation, our research focuses on metrics that Verilog can simulate such as gate counts and logical correctness of the systems. We can then combine these results with empirical research using HSPICE on CMOS and CNFET implementations to enrich this information and give context for our conclusion.

% \chapter{Experimental Hypotheses}

% \section{Hypotheses}

% Ternary systems require -36.9\% less operations and store more information than their binary counterparts \cite{kim2020logic} \cite{zahoor2024design}. Many studies have been performed in order to try and predict their benefits. This paper aims to utilise the research into various ALU designs along with instruction sets in order to create a test-bench on which various algorithms can then be run in order to verify these theoretical gains.\\
% \\
% Two comparable binary and ternary emulators will be built on which programs can be compiled and executed across both systems. Both systems will be fabricated using the same technology and contain no optimisations.\\
% \\
% Through emulating these systems we will be able to observe to what extent information density, number of interconnections, and mathematical elegance hold in practice. This will allow us to identify and verify computational tasks where ternary excels and areas where it provides little to no advantages.\\
% \\
% Due to nature of emulation and our implementation method, the are several potential drawbacks and concerns that will not be addressed. Important performance metrics such as circuit area, static and dynamic power consumption are not possible to measure or extrapolate with any meaningful accuracy. The physical implementations of the gates are not considered or emulated and therefore switching complexity, signal stability, manufacturing compatibility, and production costs have been excluded from the project hypothesis.\\
% \\
% In order to be able to compare these technologies, comparative metrics are needed. A trivial method would be to count the number of gates used in both designs. This will be a direct reflection of the circuit density required to perform the same computation. We therefore will use this as a baseline comparison for our experiment but will require a few assumptions. Another more complex method would be to measure the propagation delay of each component to then calculate the time delay of the critical path through the circuit. However this intrinsically relies on the specific hardware used for implementation. This method would give us exposure to the current performance of the state of the art implementation methods for both systems and skew our results given the decades more research into binary computation. Therefore some assumptions will be made in order to allow for a more hardware agnostic comparison.

\chapter{Experimental Design}

\section{Shared System Architecture}

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{figures/High Level Architecture.drawio.png}
    \caption{High Level System Architecture Design}
    \label{fig:system-architecture}
\end{figure}

The system has 3 states of operation; LOADING, EXECUTING, and HALTED. The system initiates in the LOADING state and as shown in Figure \ref{fig:system-architecture}, a control signal is used to instruct the program loading component to to read instructions from a hex file into the memory module sequentially upon each clock cycle. The memory bus allows the program loader and the processor to share the same connection to the memory module. Collisions are carefully managed by the system to ensure that only one of the modules can use the bus in any given state.\\
\\
Once all instructions are loaded, the program loader signals to the system that loading is complete and the system transitions into the EXECUTING state. A control signal "execute" is then enabled allowing the processor to begin the fetch-decode-execute cycle. The program counter is initialised to the same value of the memory address in which the first instruction for the program in located. For ternary systems, this number may be negative in order to allow for the range required for the number of opcodes within the instruction set. When a HALT instruction is encountered then the processor raises a halt flag and the clock cycle is stopped, effectively shutting down the system.\\
\\
Notice a deliberate exclusion of an I/O module from the system as I/O operations often introduce significant and unpredictable latency factors that are largely independent of the core CPU architectures we are testing. Removing this extra complexity creates a more controlled environment to perform reflective comparisons by statically loading and executing programs within their respective paradigms.\\
\\
While the internals within the Program Loader and Memory modules differ across the two bases, the differences in design are small. The downstream effects on the performance of the system will be minimal with any benchmarks being isolated to the performance of the CPU alone. Therefore their exact designs will not be discussed within this paper.

\section{Processor Designs}

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{figures/Processor Architecture.drawio.png}
    \caption{Processor Architecture Design}
    \label{fig:processor-architecture}
\end{figure}

Figure \ref{fig:processor-architecture} shows the components and connections with the processor for each paradigm. The control module takes the current opcode as input to maintain the current state of the CPU. It has the following internal states; FETCH, REGLOAD, ALU, REGSTORE, LOAD, STORE, NEXT, HALT. Figure \ref{fig:control-states} shows the transition between each the states where each transition is triggered on the rising edge of the clock. The REGLOAD state is effectively the decode part of the cycle where the instruction is broken down into its components and the registers required are identified. All arithmetic and logic instructions are delegated to the ALU module with inputs being passed with respect to it's type e.g. R-type or I-type. Transitions into the NEXT state default to an increment of 1 but contain flags that allow them to jump to particular addresses or branch a relative amount forward or backwards.\\
\\
In order to manage the complexity of the system, the processor will not be pipelined and instead instructions will be processed sequentially within the fetch-decode-execute-cycle. Removing this optimisation will reduce development time and allow us to focus on creating a complete test-bench.\\
\\
The ALU will house the largest changes in architecture between the two bases with circuits needing to be designed for each arithmetic/logical operation. For notation, any ternary components within a circuit diagram are denoted with a small triangle in the bottom right of the gate as shown in Figure \ref{fig:ternary-half-adder}. The absence of the triangle in the bottom right of the gate diagram directly indicates the gate uses binary logic as shown in \ref{fig:binary-full-adder}.\\

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Processor State Transition.drawio.png}
    \caption{Control Module State Transition Diagram}
    \label{fig:control-states}
\end{figure}

\section{Word Composition}

The composition of the instructions was driven by a need to maximise efficiency between systems without deliberately compromising the performance and compatibility of any given system. Extending the work of Kam et al. gives us a ternary word length of 9 \cite{kam2022design}. Selecting a binary word length of 15 would give an efficiency of $60.07\%$ but would result in using a non-standard bus width for binary. Therefore despite the loss in efficiency we will be designing a 16 bit binary system to match industry standards.\\
\\
Jeong et al. show a ternary representation requires $63.1\%$ of characters needed for it's binary representation. With our selected word sizes the expected reduction is $56.25\%$ and all comparisons made with between then should be drawn against this updated value to negate the skew of adding an extra binary bit.\\
\\
Words will be comprised of 4 components; Opcode, Register Address, Small Immediate, and Large Immediate that will have to be sized accordingly based of instruction types.\\
\\
Opcode length is dependent of the number of instructions in our set which is 16. Although this would fit nicely into 4 bits, specific START and HALT instructions will be invaluable when performing the benchmarks and therefore 5 binary bits versus 3 ternary trits will be used providing an efficiency of $84.38\%$ efficiency.\\
\\
By carefully selecting the number of general purpose registers to be 8, an efficiency of $88.89\%$ can be achieved utilising 3 binary bits and 2 ternary trits for the binary and ternary system respectively.\\
\\
For the immediate fields, due our selection of a $16$ bit binary bus width we take a large reduction in efficiency resulting in an efficiency of $37.50\%$ and $68.75\%$ for the small and big immediate respectively. A summary of the composition of each word can be found in Table \ref{tab:word-split}.

\begin{table}[h]
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    Breakdown & Bits & Binary Range & Trits & Ternary Range & $\mathbb{T} \cup \mathbb{B}$ Range & Efficiency \\
    \hline
    Opcode & $5$ & $[0-31]$ & $3$ & $[0-26]$ & $[0-26]$ & $84.38\%$ \\
    Register & $3$ & $[0-7]$ & $2$ & $[0-8]$ & $[0-7]$ & $88.89\%$ \\
    Small Immediate & $2$ & $[0-3]$ & $2$ & $[0-8]$ & $[0-3]$ & $37.50\%$ \\
    Big Immediate & $8$ & $[0-255]$ & $4$ & $[0-80]$ & $[0-80]$ & $68.75\%$ \\
    \hline
    \end{tabular}
    \caption{Binary and Ternary Word Composition}
    \label{tab:word-split}
\end{table}

\section{Ternary Design}

\subsection{Instruction Set}

The following paper \cite{kam2022design} outlines a RISC based ART-9 ternary instruction set which using a recent study \cite{li2019reduce} from 2019 to identify and build an optimised instruction set. Table \ref{tab:ternary-instruction-set} shows the diff between their proposed instruction set and required changes made in order to ensure a fair comparison. It utilises the typical RISC load-store architecture that can be grouped into the following 4 categories; R-type (Register), I-type (Immediate), B-type (Branch), and M-type (Memory). This grouping dictates how the 9-trit long words should be broken down their into their representative chunks as shown in figure \ref{tab:word-split}.\\
\\
The architecture outlines a single special-purpose 9-trit register for use a program counter (PC) in order to store the current instruction address. Like most modern processor architectures, the core also includes nine 9-trit general purpose registers that can be accessed using 2 trit indices that are denoted by Ta and Tb. Overwriting results to these general purpose registers is denoted by TRF[Ta]. As shown in table \ref{fig:is-split} our design will only be using 8 general purpose registers due to the decision for the binary system to use 3 bits for register addresses as shown in Table \ref{tab:word-split}.
\\
Another deviation from this architecture is in the R-type instruction (COMP) as Kam et al. outlines updates to the least significant trit (LST) with TRF[Ta] being set to $0$ if equal, otherwise $+1$ if TRF[Ta] $>$ TRF[Tb] and $-1$ if TRF[Ta] $<$ TRF[Tb]. While this plays an important role in improving code density in favour of ternary, we are looking to perform a comparative analysis and implementing the same capability into a binary system would require increasing the instruction set size. The consequences of this would be more CPU cycles for binary resulting in skewed results when looking at the raw computation efficiency of the paradigms. Instead as shown in Table \ref{tab:ternary-instruction-set} we will be breaking this down into two instructions less-than (LT) and equal-to (EQ). Both instructions will only update the LST of the register, in other words the value to $+1$ if TRF[Ta] $>$ TRF[Tb] or TRF[Ta] $==$ TRF[Tb] for each instruction respectively, $0$ otherwise.\\
\\
All shifts ($<<$ and $>>$) have been removed from the instruction set due to being inherently coupled with the base of the system they operate in. Programs that require multiplying/dividing by 2 would naturally lend themselves to binary but would require more compute in base 3 with the same being true for vice versa.\\
\begin{table}
    \centering
    \begin{tabular}{|c|c|l|l|}
    \hline
     & Type & 9-trit instructions & Operation \\
    \hline
     & R & MV Ta,Tb & TRF[Ta] = TRF[Tb] \\
     \rowcolor{pink!40} - & R & PTI Ta,Tb & TRF[Ta] = PTI(TRF[Tb]) \\
     \rowcolor{pink!40} - & R & NTI Ta,Tb & TRF[Ta] = NTI(TRF[Tb]) \\
     & R & NOT Ta,Tb & TRF[Ta] = STI(TRF[Tb]) \\
     & R & AND Ta,Tb & TRF[Ta] = TRF[Ta] $\wedge$ TRF[Tb] \\
     & R & OR Ta,Tb & TRF[Ta] = TRF[Ta] $\vee$ TRF[Tb] \\
     & R & XOR Ta,Tb & TRF[Ta] = TRF[Ta] $\oplus$ TRF[Tb] \\
     & R & ADD Ta,Tb & TRF[Ta] = TRF[Ta] $+$ TRF[Tb] \\
     & R & SUB Ta,Tb & TRF[Ta] = TRF[Ta] $-$ TRF[Tb] \\
     \rowcolor{pink!40} - & R & SR Ta,Tb & TRF[Ta] = TRF[Ta] $\gg$ TRF[Tb][1:0] \\
     \rowcolor{pink!40} - & R & SL Ta,Tb & TRF[Ta] = TRF[Ta] $\ll$ TRF[Tb][1:0] \\
     \rowcolor{pink!40} - & R & COMP Ta,Tb & TRF[Ta] = compare(TRF[Ta],TRF[Tb]) \\
     \rowcolor{green!15} + & R & LT Ta,Tb & TRF[Ta] = TRF[Ta] $<$ TRF[Tb] \\
     \rowcolor{green!15} + & R & EQ Ta,Tb & TRF[Ta] = TRF[Ta] $==$ TRF[Tb] \\
     & I & ANDI Ta,imm & TRF[Ta] = TRF[Ta] $\wedge$ imm[2:0] \\
     & I & ADDI Ta,imm & TRF[Ta] = TRF[Ta] $+$ imm[2:0] \\
     \rowcolor{pink!40} - & I & SRI Ta,imm & TRF[Ta] = TRF[Ta] $\gg$ imm[1:0] \\
     \rowcolor{pink!40} - & I & SLI Ta,imm & TRF[Ta] = TRF[Ta] $\ll$ imm[1:0] \\
     & I & LUI Ta,imm & TRF[Ta] = \{imm[3:0],00000\} \\
     & I & LI Ta,imm & TRF[Ta] = \{TRF[Ta][8:5],imm[4:0]\} \\
     & B & BEQ Ta,B,imm & PC = PC + imm[3:0] if TRF[Ta][0] $=$ B \\
     & B & BNE Ta,B,imm & PC = PC + imm[3:0] if TRF[Ta][0] $\neq$ B \\
     \rowcolor{pink!40} - & B & JAL Ta,imm & TRF[Ta] = PC+1, PC = PC + imm[4:0] \\
     \rowcolor{pink!40} - & B & JALR Ta,Tb,imm & TRF[Ta] = PC+1, PC = PC + imm[4:0] \\
     & M & LOAD Ta,Tb,imm & TRF[Ta] = TDM[TRF[Tb]+imm[2:0]] \\
     & M & STORE Ta,Tb,imm & TDM[TRF[Tb]+imm[2:0]] = TRF[Ta] \\
    \hline
    \end{tabular}
    \caption{Kam et al's Adjusted 9-trit Instruction Set Architecture}
    \label{tab:ternary-instruction-set}
\end{table}

\subsection{Function Selection}

In existing ternary ALU designs such as those proposed by \cite{sharma2020energy} discuss the gates required to select the correct function given the opcode. Their proposed design uses 2 ternary decoders followed by 9 and gates. Mixing logical bases to perform function selection reduces the area overhead of the transistors required by $35.15\%$. Using this design would void any direct comparisons between the systems should the ternary system contain binary logic in order to reduce the number of transistors required.\\
\\
In this paper, function selection will be implemented at the behavioural level in order to avoid this scenario but will be discussed as a limitation of the experiment in context of the results.

\subsection{Logical Operations}

For all logical ternary operations such as; STI, AND, OR, and XOR, the circuitry can be performed in parallel by applying single gate to each of the trits within the word of length $n$. In other words, performing an AND operation between two values requires $n$ AND gates arranged as shown in Figure \ref{fig:ternary-and-operation}.\\
\\
As all of these operations possess the property that each output $R_i$ is only ever dependent on its input pair $A_i$ and $B_i$. Therefore we can use reuse the same construction, the AND gate can be swapped out for any of the others listed above to create the circuit we need.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.2\linewidth]{figures/Ternary AND gates.drawio.png}
    \caption{Ternary AND Operation}
    \label{fig:ternary-and-operation}
\end{figure}
Let $x$ be the number of CNFET's required to create an individual gate within the circuit, the total number of CNFET's will be directly proportional to the word length $n$ giving a total of $xn$. The propagation delay $\tau$ will be equivalent to the delay of one individual gate used to construct the circuit.

\subsection{Addition}

A critical component of an ALU is the addition gate, it's implementation needs to be considered carefully. As with all numerical base systems, addition requires implementing a carry system. \cite{jaber2023ternary} proposes two new Ternary Full Adders (TFA) that reduce the transistor count down to 59 CNFET's with TFA1 and 55 CNFET's with TFA2. They compare their design with 11 other TFA designs rooted in CNFET technology which mainly discuss their performance via transistor counts and power efficiency. The step in performance comes from their combination of two different Ternary Multiplexers (TMUX), both of which are unary operators with 2 inputs and 3 inputs respectively. However, these circuits rely on ternary specific operations such as NTI and PTI which do not have direct binary counterparts making a comparison between solutions more difficult.\\
\\
Therefore instead we will be implementing a ripple-carry adder without any carry-lookahead. The sequential nature of feeding the carry of the previous pair of digits forward means that propagation time increases linearly with the word length \cite{duret-robert2019ternalu3}. This effect will be present in both systems although favouring ternary due to the shorter word length.\\
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        $A$ & $B$ & Sum & Carry \\
        \hline
        $1$ & $1$ & $1$ & $T$ \\
        $1$ & $0$ & $1$ & $0$ \\
        $1$ & $T$ & $0$ & $0$ \\
        $0$ & $1$ & $1$ & $0$ \\
        $0$ & $0$ & $0$ & $0$ \\
        $0$ & $T$ & $T$ & $0$ \\
        $T$ & $1$ & $0$ & $0$ \\
        $T$ & $0$ & $T$ & $0$ \\
        $T$ & $T$ & $T$ & $1$ \\
        \hline
    \end{tabular}
    \caption{Balanced Ternary Half Adder Truth Table}
    \label{tab:ternary_half_adder_truth}
\end{table}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Ternary Half Adder.drawio.png}
    \caption{Ternary Half Adder}
    \label{fig:ternary-half-adder}
\end{figure}
\\
Notice how Table \ref{tab:ternary_half_adder_truth} requires a ternary output for both the sum and carry compared to a unbalanced ternary system that would only require a positive carry. A balanced ternary half adder can be created by combining an addition gate (sum) with a consensus gate (carry) as shown in figure \ref{fig:ternary-half-adder}. An addition gate can be manufactured from the fundamental gates by combining consensus (CONS) gate with 3 any (ANY) gates as shown in figure \ref{fig:ternary-addition-gate}.\\
\begin{displaymath}
    A \oplus B = (A \boxplus B \boxplus \overline{A \boxtimes B}) \boxplus \overline{A \boxtimes B}
\end{displaymath}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Ternary Addition Gate.drawio.png}
    \caption{Ternary Addition in Fundamental Gates}
    \label{fig:ternary-addition-gate}
\end{figure}
\\
Two ternary half-adders can then be combined to make a ternary full adder (TFA) with the two carries being combined with an any (ANY) gate as shown in Figure \ref{fig:ternary-full-adder}.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Ternary Full Adder.drawio.png}
    \caption{Ternary Full Adder}
    \label{fig:ternary-full-adder}
\end{figure}
\\
Chaining $n-1$ full adders together with an half adder for the first input allows us to add together two numbers with a word length of $n$ as shown in Figure \ref{fig:ternary-ripple-carry}. This setup provides us with an overflow flag, that will signal when the resultant falls outside of the range of the architecture. We will not be implementing error checking with the processors so will need to take this into consideration when designing the testbenches otherwise we will encounter undefined behaviour.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.2\linewidth]{figures/Ternary Ripple-Carry Adder.drawio.png}
    \caption{Ternary Ripple-Carry Adder}
    \label{fig:ternary-ripple-carry}
\end{figure}\\
Using the information in Table \ref{fig:two_value_ter_gates} we can analyse this configuration in terms of number of CNFET's required to represent it along with it's associated propagation delay in relation to $\tau$.\\

\subsection{Subtraction}

Due to the symmetric property of balanced ternary, values can be easily converted from positive to negative. Therefore subtraction can be performed by simply negating each trit of the second argument before using the addition circuit as shown in Figure \ref{fig:ternary-subtraction}. All buses are indicated using vector notation indicated by the arrow over variable name. Please note all vectors in Figure \ref{fig:ternary-subtraction} are of width 9 in with the negation being performed by the STI gate as discussed above in Logical Operations. The overflow is a redundant flag as no error handling is present within the design.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{figures/ternary subtraction.drawio.png}
    \caption{Ternary Subtraction Circuit}
    \label{fig:ternary-subtraction}
\end{figure}\\
The propagation delay $\tau$ and gates counts of this circuit is sum of the negation plus the delay of the addition circuit due to the critical path going through both components.

\section{Binary Design}

\subsection{Instruction Set}

Further modifications to the RISC based instruction set proposed by Kam et al. can be made for an binary equivalent. Due to our careful selection of the word length and their respective subdivisions in both paradigms, Table \ref{tab:word-split} outlines the changes in size needed for each instruction and the resulting instruction set is shown in Table \ref{tab:binary-instruction-set}\\
\\
The ternary instruction set was also designed to make sure there was bijective map between the instruction sets so that the complier would be able to generate the same number of instructions in both bases.\\
\begin{table}
    \centering
    \begin{tabular}{|c|c|l|l|}
        \hline
         & Type & 16-bit instructions & Operation \\
        \hline
        0 & R & MV a,b & RF[a] = RF[b] \\
        2 & R & NOT a,b & RF[a] = NOT(RF[b]) \\
        4 & R & AND a,b & RF[a] = RF[a] $\wedge$ RF[b] \\
        5 & R & OR a,b & RF[a] = RF[a] $\vee$ RF[b] \\
        6 & R & XOR a,b & RF[a] = RF[a] $\oplus$ RF[b] \\
        7 & R & ADD a,b & RF[a] = RF[a] $+$ RF[b] \\
        8 & R & SUB a,b & RF[a] = RF[a] $-$ RF[b] \\
        11 & R & COMP a,b & RF[a] = compare(RF[a],RF[b]) \\
        4 & R & ANDI a,b & RF[a] = RF[a] $\wedge$ imm[7:0] \\
        7 & R & ADDI a,b & RF[a] = RF[a] $+$ imm[7:0] \\
        7 & R & LT a,b & RF[a] = RF[a] $<$ RF[b] \\
        7 & R & EQ a,b & RF[a] = RF[a] $==$ RF[b]\\
        16 & I & LUI a,imm & RF[a] = \{imm[7:0],00000000\} \\
        17 & I & LI a,imm & RF[a] = \{RF[a][15:8],imm[7:0]\} \\
        22 & M & LOAD a,b,imm & RF[a] = TDM[RF[b]+imm[4:0]] \\
        23 & M & STORE a,b,imm & TDM[RF[b]+imm[4:0]] = RF[a] \\
        24 &   & HALT & \\
        \hline
    \end{tabular}
    \caption{16-bit Instruction Set Architecture}
    \label{tab:binary-instruction-set}
\end{table}
LUI is an edge case as it exhibits distinctly different behaviour depending on the base the instruction is being executed in. For binary, loading the value $1$ into the top of the register results in value of $256$ in but in ternary the resulting value is $81$ in the context of our instruction set design. To achieve comparable behaviour as we would need to define a big immediate size with the following property:
\begin{equation*}
    \exists i,j \in \mathbb{N} : 2^i = 3^j
\end{equation*}
Where we consider the set $\mathbb{N}$ to contain 0 as per the definition of non-negative integers. Figure \ref{fig:lui-immediate-sizing} shows that $i=0$, $j=0$ is a possible solution. However, this is the padding used by the instruction LI to achieve the desired behaviour of loading the same value into the register. Therefore we would need to find a non-zero solution for our big immediate size in order to be able to achieve this behaviour.\\
\\
Proving this is impossible can be done using prime factorisation but a more elegant solution is to observe that $3^i$ is odd for all values of $i \in \{\mathbb{N}/0\}$ and that $2^i$ is even for all values of $i$ and therefore has no possible solution.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/exponential_functions.png}
    \caption{Binary vs. Ternary Immediate Sizing}
    \label{fig:lui-immediate-sizing}
\end{figure}
When designing the compiler, this problem can be effectively eliminated by creating a single instruction to load in values of size proportional to the full width of the bus.

\subsection{Function Selection}

In line with the ternary implementation, the binary ALU will also use behavioural logic and therefore will not be included in the metrics when performing the comparison between the systems.

\subsection{Logical Operations}

For all logical binary operations such as: NOT, AND, OR, and XOR, the same structure used in our ternary ALU can be applied as shown in Figure \ref{fig:binary-and-operation} for our binary implementations.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.2\linewidth]{figures/Binary AND gates.drawio.png}
    \caption{Binary AND Operation}
    \label{fig:binary-and-operation}
\end{figure}
Let $y$ be the number of CMOS's required to create an individual gate within the circuit, the total number of CMOS's will be directly proportional to the word length $n$ giving a total of $xn$. The propagation delay $\tau$ will also be equivalent to the delay of one individual gate used to construct the circuit.

\subsection{Addition}

The binary base operation was taken into consideration when designing the ternary addition circuit allowing binary addition implementation to use a similar logic structure. Observations made on the proposed ternary setup such as propagation time increasing linearly will also hold for this design.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Binary Half Adder.drawio.png}
    \caption{Ternary Half Adder}
    \label{fig:binary-half-adder}
\end{figure}
A binary half adder can be created by combining an XOR gate (sum) with and AND gate (carry) as shown in figure \ref{fig:binary-half-adder}. One significant difference for binary is that a half adder can be constructed from just two fundamental gates as opposed to using 5 fundamental ternary gates.\\
\\
Two binary half-adders can then be combined to make a binary full adder with the two carries being combined with an or (OR) gate as shown in Figure \ref{fig:ternary-full-adder}.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Binary Full Adder.drawio.png}
    \caption{Ternary Full Adder}
    \label{fig:binary-full-adder}
\end{figure}
Resulting in an almost identical ripple carry adder set-up as shown in Figure \ref{fig:binary-ripple-carry}. Combining this with our research into gate representation using CMOS logic we can analyse this configuration in terms of number of CMOS pairs required to represent it along with it's associated propagation delay $\tau$.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.2\linewidth]{figures/Binary Ripple Carry Adder.drawio.png}
    \caption{Binary Ripple-Carry Adder}
    \label{fig:binary-ripple-carry}
\end{figure}

\subsection{Subtraction}

Although not symmetric, values can be converted from positive to negative by negating each bit before then adding one. Performing this operation stand-alone requires using a ripple carry adder to perform the $+1$ addition.\\
\\
As subtraction already requires implementing a ripple carry adder, setting the carry in to the binary value $1$ is logically equivalent to implementing two adders. As shown in Figure \ref{fig:binary-ripple-carry} as $C_{in}$ the carry in has been added to the first binary full adder when compared to the ternary implementation.\\
\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{figures/Binary Subtractor.drawio.png}
    \caption{Binary Subtraction Circuit}
    \label{fig:binary-subtraction}
\end{figure}\\
Figure \ref{fig:binary-subtraction} shows the setup is very similar to the ternary design where the propagation delay $\tau$ and gates counts is just a simple sum of the two individual gates.\\
\\
In this specific example, implementing a carry input negates this theoretical advantage of ternary logic and will push the comparison in favour of binary for any results obtained using the subtraction circuit.

\section{Implications of not Optimising}

The number of CMOS and CNFET components used in the binary and ternary circuits can be reduced by considering the inverted equivalents of these logical operations. Figure \ref{fig:cmos-or-gate} and \ref{fig:cmos-nor-gate} shows that an OR gate costs 6 CMOS components whereas a NOR gate gate costs 4 CMOS components \cite{allaboutelectronicsCMOSLogic}.
\begin{figure}[h]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/CMOS OR Gate.png}
        \caption{CMOS Binary OR Gate}
        \label{fig:cmos-or-gate}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/CMOS NOR Gate.png}
        \caption{CMOS Binary NOR Gate}
        \label{fig:cmos-nor-gate}
    \end{minipage}
\end{figure}
This reduction in CMOS components is due to the structural composition of an OR gate being a NOR gate with an inverter placed before the output stage. In other words, the cost of OR gate is the the cost of a NOR plus the cost of a NOT gate. This design arises from fundamental properties of CMOS technology where a NOR gate can be directly implemented with a complementary arrangement of transistors. This trend holds over other fundamental gates including AND and NAND where they cost 6 and 4 CMOS components respectively but does not extend to gates such as XOR and XNOR which both require 8 transistors.\\
\\
In CNFET-based ternary logic gates, a similar architectural complexity can also be observed in certain fundamental gates including AND and NOR. Figures \ref{fig:jaber-ternary-inverter}\ref{fig:jaber-ternary-nand}\ref{fig:cnfet-ternary-nor} located in the Appendix show proposed designs for a STI, NAND, and NOR. A ternary half-adder design is also presented in the paper where the logical behaviour of an OR gate is created by chaining a NOR gate with a STI \cite{khurshid2023energy}. Requiring 10 transistors for the NOR and 5 for the STI, a ternary OR gate requires 15 transistors.\\
\\
Significant reduction in transistor count can be found in both bases by maximising the number of inverted gates within any given circuit while maintaining logical equivalence. Using this technique, Duret was able reduce the number of CMOS pairs within a TFA from $31n-26$ to $24n-6$ where $n$ represents the width of the bus \cite{duret2019ternaryALU}. Although using CMOS technology to perform ternary logic, for our bus width of 9 we could expect a reduction of $53$ CMOS pairs from $253$ to $200$.\\
\\
Not utilising these optimisations will not favour either of the bases as both would benefit from a $50\%$ reduction in transistor count from this property that arises from the technologies lending themselves to particular arrangements of inverted gates. 

\chapter{Testbench Design}

In order to be able to compare and contrast our systems, a framework is needed in order to compile programs to run on both the binary and ternary processors while gathering and outputting metrics during runtime for later analysis.

\section{Compiler}

The compiler is written in python and takes an \textit{.asm} file as input and produces two \textit{.hex} files for each system where each line is 16 bits and 18 bits for binary and ternary respectively. Representing a single trit as two bits enables the use of a hex file for the ternary system but careful management is needed in order to ensure these binary strings are treated as ternary values. Like the Verilog implementation, the compiler defines constants that represent the 3 ternary states which are used to encode the ternary values into the hex files.\\
\\
The assembly language declares immediate values in denary which then naturally need to be translated with ternary requiring an extra step in the process. First the denary value has to be converted into a ternary representation which is then encoded into binary using the constant definitions. As shown in tables \ref{tab:binary-instruction-set} and \ref{tab:ternary-instruction-set} instructions are divided into 5 distinct types (including HALT) which inform the compiler of the instructions composition. For example, Binary R-type instructions are composed of an opcode ($5$ bits) plus two register addresses ($3$ bits each).\\
\\
The compiler performs no optimisations during the compilation and simply parses each instruction line by line. In order to get around the issue discussed above in the binary instruction set section, a zero cost abstraction called LOADI has been implemented. This allows programs to immediately load values of the bus width into registers. The compiler achieves this by splitting this instruction into a LUI and LI which abstracts away the complexity of computing the required individual values to represent the desired value within the register. This allows programs to be completely agnostic to the base of the target systems.

\section{Program Selection}

\subsection{Algorithm Neutrality}

When designing our experimental framework, deliberate choices were made to ensure a fair comparison between binary and ternary systems. Most significantly, we have either redesigned or eliminated operations that would inherently favour one numerical base over the other. For example, shift operations ($<<$ and $>>$) have been removed from our instruction set entirely, as these operations are intrinsically optimised for the base in which they operate. In binary systems, left shifts efficiently multiply by powers of 2, while in ternary systems, they would multiply by powers of 3. Including such operations would skew our results toward the base that better aligns with the specific algorithmic being tested. Therefore naturally we will not be considering these operations in our results.

\subsection{Primitive ALU Operations}

Executing individual ALU operations on each processor will allow us to isolate particular circuits to provide a comprehensive comparison between the binary and ternary paradigms. Collecting metrics using this approach allows us to extrapolate the underlying performance characteristics of each system. We categorise the ALU operations into two distinct groups based on their execution patterns:
\begin{enumerate}
    \item \textbf{Basic Operations}: These operations can be performed in parallel across the entire word length, with each bit/trit processed independently of adjacent positions. Examples include NOT, AND, OR, and XOR.
    \item \textbf{Complex Operations}: These operations contain inherently sequential components whose result is dependent on the processing of adjacent bits/trits. Examples include ADD, SUB, and comparison operations that involve propagation of carry or borrow values.
\end{enumerate}\\
The ADD operation warrants particular focus in our analysis as it forms a fundamental building block for numerous CPU operations, including address calculation, array indexing, and pointer arithmetic. Furthermore, the ADD operation directly influences the performance of other complex operations such as SUB and multiplication. Any efficiency gains in the addition circuit will therefore compound into significant performance improvements across the entire system.\\
\\
For each operation, we will observe gate counts, transistor requirements, and propagation delay to provide a wider view of performance. This data will reveal whether the theoretical advantages of ternary logic translates to practical performance benefits in real-world computational scenarios.

\section{Interface}

To facilitate the compilation and testing process across both binary and ternary systems, a web-based interface was developed using React as shown in Figure \ref{fig:system-interface}. This interface provides a structured environment for users to interact with the compiler to generate and visualise the results of program execution on both architectural paradigms.\\
\\
The assembly input area allows users to enter code directly or select from predefined program templates where these templates will be a subset of the range of programs used to generate the results discussed in the section below. Documentation is available on the instruction set including information on operations and their respective syntax.
\\
Upon compilation, the interface processes the assembly code through the dual-target compiler described in Section 7.1, generating both binary and ternary machine code. Execution results from both systems are captured and displayed in the console output panel, allowing for direct comparison of execution metrics.
\\
Performance analysis is presented through automatically generated graphs that visualise gate counts for different operations across both systems. These visualisations quantify the relative efficiency of binary versus ternary implementations for specific computational tasks. The data can be exported in standard formats for further analysis.
\\
The primary function of this interface is to serve as an experimental platform where researchers can test hypotheses regarding binary and ternary computational efficiency. The modular design allows for periodic updates of the empirical values from contemporary CNFET and CMOS technologies, ensuring that propagation delay comparisons remain representative of state-of-the-art implementations.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/system_interfrace.png}
    \caption{System Interface Screenshot}
    \label{fig:system-interface}
\end{figure}

\chapter{Results}

Analysis of results focuses on gate counts, transistor counts, and propagation delays across various basic and complex ALU operations providing insight into the theoretical and practical advantages of each paradigm.

\section{Gate Count Analysis}

\subsection*{Basic Operations}

Figure \ref{fig:basic-gate-counts} indicate that ternary implementations require fewer gates for basic operations compared to binary implementations. This reduction directly correlates with the decreased word length in ternary representation (9 trits versus 16 bits), supporting the theoretical information density advantage of ternary logic. For operations such as; NOT, AND, OR, and XOR the gate count reduction is $56.25\%$ which correlates with the theoretical gain in efficiency we expected to observe as discussed in the Word Composition section.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/trivial_gate_usage.png}
    \caption{Basic ALU Operation Gate Counts}
    \label{fig:basic-gate-counts}
\end{figure}

\subsection*{Complex Operations}

Contrary to basic operations, more complex operations demonstrate an increase in gate count for ternary implementations as shown in Figure \ref{fig:complex-gate-counts}. Operations ADD, SUB, and Multiplication represent the largest disparity due to their heavy reliance on CONSENSUS and ANY gates, which themselves require multiple CNFET's to implement their respective logic. This effect is most present in Multiplication due to the stacking of multiple operations resulting in significantly larger numbers of ternary gates being required.\\
\\
The operation Less Than operation is the exception to this trend, using less ternary gates of every type (except or). This may be due to binary nature of positive and negative ternary inverters only have 2 possible outputs reducing the complexity of the circuit. The data indicates that already the overhead of constructing complex ternary operations has offset the benefits gained from shorter word length predicted by information density calculations.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/complex_gate_usage.png}
    \caption{Complex ALU Operation Gate Counts}
    \label{fig:complex-gate-counts}
\end{figure}

\section{Transistor Requirement Analysis}

The gate counts can then be combined with the number of transistors used in each gate as show in Table \ref{tab:gate_characteristics} to produce figures more directly comparing using the metric of transistor requirements for each ALU operation.

\subsection*{Basic Operations}

Despite the reduction in gate count for basic operations, analysis of transistor requirements in Figure \ref{fig:basic-transistor-counts} reveals that binary implementations remain more efficient. CMOS technology requires approximately $4$-$6$ transistors per binary gate such as AND, OR NAND, NOR whereas the same ternary gates in CNFET technology require $10$-$15$ transistors. However for the XOR operation, ternary requires less transistors to implement due to the binary CMOS implementation using $12$ transistors compared to $18$ CNFET's, not a large enough difference to overcome the word length disparity.\\
\\
These results are still overall in favour of binary implementations using fewer transistors than equivalent ternary implementations for basic operations with the current state of CNFET gate designs.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/basic_transistor_count.png}
    \caption{Basic ALU Operations Transistor Counts}
    \label{fig:basic-transistor-counts}
\end{figure}

\subsection*{Complex Operations}

Not unexpectedly, Figure \ref{fig:complex-transistor-counts} shows the transistor count disparity becomes more pronounced for complex operations. Ternary implementations require an approximately $300\%$ more transistors compared to binary equivalents due to both the increased number of gates and the higher transistor count per gate. Operations such as addition demonstrate this effect most clearly, requiring $2115$ transistors in ternary versus $704$ in binary. This would require CNFET's to require approximately $33.2\%$ of the area of CMOS implementation to have the same chip footprint.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/complex_transistor_count.png}
    \caption{Complex ALU Operations Transistor Counts}
    \label{fig:complex-transistor-counts}
\end{figure}

\section{Propagation Delay Comparison}

Table \ref{tab:circuit_propagation_delay} shows a summary of the propagation delay for each gate with respect to the underlying technology being used to implement it. For the basic gates the propagation delay is simply taken from Table \ref{tab:gate_characteristics} whereas the complex gates have to be calculated. By observing the circuit design for each complex component as indicated in the source column, we are able to observe the critical path and calculate using the propagation of it's basic components. As only the design of addition and subtraction have been documented within this paper, only their propagation delays will be considered in this section of the results.

\begin{table}[h]
    \centering
    \begin{tabular}{|c|l|c|c|c|}
        \hline
        & Circuit Component & \makecell{CMOS\\Delay ($\tau$)} & \makecell{CNFET\\Delay ($\eta$)} & Source \\
        \hline
        \multirow{8}{*}{\rotatebox[origin=c]{90}{\makecell{Basic Components}}} 
        & NOT & $1\tau$ & $2\eta$ & \\
        & NTI & - & $2\eta$ & \\
        & PTI & - & $2\eta$ & \\
        & AND & $2\tau$ & $5\eta$ & \\
        & NAND & $2\tau$ & $3\eta$ & \\
        & OR & $2\tau$ & $5\eta$ & \\
        & NOR & $2\tau$ & $3\eta$ & \\
        & XOR & $3\tau$ & $4\eta$ & \\
        \hline
        \multirow{6}{*}{\rotatebox[origin=c]{90}{\makecell{Complex\\Components}}} 
        & CONS & - & $12\eta$ & \\
        & ANY & - & $6\eta$ & \\
        & Addition & - & $18\eta$ & \\
        & Half Adder & $3\tau$ & $18\eta$ & \\
        & Full Adder & $8\tau$ & $42\eta$ & \\
        \hline
    \end{tabular}
    \caption{Circuit Propagation Delay Characteristics for CMOS and CNFET Gates}
    \label{tab:circuit_propagation_delay}
\end{table}

Figure \ref{fig:operation_prop_delay} assumes that both technologies have an equivalent switching delay and shows that for all ALU operations designed and documented in this report, ternary shows a significantly larger propagation delay. This would potentially limit maximum clock speeds of the ternary processor too $34\%$ of the binary processor for the same computation.

\begin{figure}[h]
    \centering
    \begin{minipage}{0.49\textwidth}
        \centering   
        \includegraphics[width=0.8\linewidth]{figures/prop_delay_basic.png}
    \end{minipage}
    \begin{minipage}{0.49\textwidth}
        \centering
        \includegraphics[width=0.8\linewidth]{figures/prop_delay_complex.png}
    \end{minipage}
    \caption{ALU Operations Propagation Delay (Assumes $\tau \equiv \eta$)}
    \label{fig:operation_prop_delay}
\end{figure}

\section{Empirical Analysis}

Figure \ref{fig:operation_prop_delay} shows the propagation delay difference under the assumption that $\tau \equiv \eta$. Using empirical results found in Figure \ref{fig:node-prop-delay} we can substitute in values for $\tau$ and $\eta$ at difference node sizes. Using the values $\tau=9.55$ps and $\eta=3.11$ at a node size of $32$nm results in Figure \ref{fig:emp_complex_prop_delay}. $32$nm was chosen due to larger CMOS devices having significantly larger switching delays while as we approach $10$nm we will encounter unknown behaviour within CNFET gates not accounted for with this model.\\
\\
This Figure shows the projected propagation delay of our operations we would expect from a direct hardware implementation. Our research has shown that CNFET's can offer switching delay advantages over conventional CMOS technology which can be seen overcoming the disparity in the quantity of transistors required. This speaks more of the current state of CNFET design than that of ternary logic. The underlying performance of CNFET's is bailing out the current inefficiencies in ternary gate designs. This aligns with other research trends showing that CNFET technology can provide significant reductions in delay at scale in larger circuit designs such as 8 Transistor SRAM design \cite{fuad2025comprehensive}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/emp_complex_prop_delays.png}
    \caption{Complex ALU Operations Propagation Delay Projection with $32$nm Nodes}
    \label{fig:emp_complex_prop_delay}
\end{figure}

\section{Summary of Findings}

When comparing similar circuit designs and given the current state of the art CNFET gate designs, the experimental results demonstrate that despite the theoretical $58\%$ potential advantage offered by ternary logic, practical implementations face significant challenges that completely negate any positive benefits. Simply computing in ternary hardware over binary hardware offers no performance gains when performing general operations.\\
\\
TODO: discuss prop delay and gate optimisation issues.\\
\\
However this is not to say the the theoretical performance cannot be realised by optimised ternary circuits that may be more competitive for particular tasks when utilising clever compilers to reduce the number of instructions/cycles required.

\chapter{Future Work and Conclusions}

\section{Limitations}

\subsection{Emulation vs. Implementation}

This study is limited by its reliance on binary encoding to emulate ternary logic, where each trit was represented using two binary bits. This approximation fails to capture physical characteristics of ternary systems, including voltage transitions, analogue effects, and signal behaviours. While our approach enables functional comparison between paradigms, these limitations affect the ability to accurately emulate circuit characteristics such as signal transitions and timing characteristics that will affect metrics such as propagation delay.

\subsection{Disparity in Hardware Maturity}

Any analysis is constrained by the maturity gap between binary CMOS and ternary CNFET technologies. Binary CMOS benefits from decades of optimisation, while CNFET-based ternary logic remains largely theoretical. This disparity results in less optimised gate designs making for a skewed true comparison. Not modelling physical phenomena such as voltage variations and parasitic capacitance that impact MVL circuit performance artificially narrows the gap. Our findings represent a comparison between optimised binary technology and early-stage ternary technology rather than a comparison at equivalent optimisation levels.

\section{Possible Future Work}

\subsection{Advancing CNFET Gate Designs}

This work does not put us in a position to say that the theoretical advantages cannot be realised in the near future. The avenue of focussing future research on developing efficient CNFET based gates that reduce the number of transistors required would allow us to say with a higher certainty that ternary logic is fundamentally flawed in real world implementations.

\subsection{Moving to True Ternary}

This work could inspire future endeavours to create ternary-native implementations that would eliminate the binary approximation used in this study. This could involve using extended HDL's such SystemVerilog that support multi-valued logic, utilising circuit simulation tools to model physical behaviour of ternary circuits such as HSPICE, or developing FPGA prototypes with ternary logic elements. While these tools would provide a wider range of metrics with a higher degree of accuracy, they would not help bridge the maturity gap between technologies.

\subsection{Unleashing the Instruction Set and Compiler}

A large part of the ternary machines potential was contained by requirements to remain directly comparable to binary. Developing ternary optimised compilers along with instruction sets that leverage properties of balanced ternary logic could gain back and amplify the theoretical information density advantages. These software approaches might make ternary computing more competitive with binary systems in particular applications, even if the hardware implementation challenges persist with current technology.

\subsection{Extending the Interface}

\section{Concluding Remarks}

This work proposed a novel design for logically creating a CONSENSUS gate using other primitive gates that can be implemented directly in CNFET technology. This enabled the implementation of addition and subtraction circuits using the same architecture as binary implementations in order to perform this comparison. The CONSENSUS gate is used to perform the carry and is expensive at 55 transistors compared to carry requiring only 6 transistors to implement a binary AND gate. A direct implementation of a CONS gate in CNFET technology would reduce this bottleneck and allow for a more favourable outlook on the future of ternary.\\
\\
Due to this limitation, we have shown that current state of the art ternary hardware design provides no general compute performance benefits. Therefore for ternary logic to be considered over existing binary logic in general computing applications, significant research into constructing more complex gates directly using CNFET arrangements is needed.\\
\\
Until the design of these gates is progressed, the number of CNFET's required to build our implementation is greater than an equivalent CMOS circuit. A CNFET transistor would have to be $66.8\%$ smaller that a CMOS transistor in order to gain any benefit. This however leads us back to the fundamental problem plaguing CMOS technology today; there is only a finite amount of transistors you can cram onto a chip \cite{moore1965cramming}.

\printbibliography

\chapter*{Appendix}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/jaber_cnfet_not_gate_diagram.png}
    \caption{Jaber et al. proposed CNFET Ternary STI Design}
    \label{fig:jaber-ternary-inverter}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/jaber_cnfnet_nand_gate_diagram.png}
    \caption{Jaber et al. proposed CNFET Ternary NAND Design}
    \label{fig:jaber-ternary-nand}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/cnfet_nor_gate_diagram.jpg}
    \caption{Khurshid et al. proposed CNFET Ternary NOR Design}
    \label{fig:cnfet-ternary-nor}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/cnfet_xor_gate_design.png}
    \caption{Murotiya et al. proposed CNFET Ternary XOR Design}
    \label{fig:cnfet-ternary-xor}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/CMOS NOT Gate.png}
    \caption{Standard 2 transistor CMOS Binary Inverter Design}
    \label{fig:cmos-binary-not}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/CMOS AND Gate.png}
    \caption{Standard 6 transistor CMOS Binary AND Design}
    \label{fig:cmos-binary-and}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/CMOS NAND Gate.png}
    \caption{Standard 2 transistor CMOS Binary NAND Design}
    \label{fig:cmos-binary-nand}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/CMOS XOR Gate.png}
    \caption{Standard 12 transistor CMOS Binary XOR Design}
    \label{fig:cmos-binary-xor}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{|c|l|p{9cm}|c|}
        \hline
        & \textbf{Gate} & \textbf{Propagation Delay Explanation} & \textbf{Delay} \\
        \hline
        \multirow{7}{*}{\rotatebox[origin=c]{90}{\textbf{Binary}}} 
        & BUF & A buffer is implemented as two inverters in series. Each inverter stage contributes 1.0$\tau$ to the total delay. & $2.0\tau$ \\
        \cline{2-4}
        & NOT & Consists of one PMOS and one NMOS transistor. The critical path involves only one transistor switching. This is the baseline unit of delay. & $1.0\tau$ \\
        \cline{2-4}
        & NAND & Implemented with 2 PMOS transistors in parallel and 2 NMOS transistors in series. The critical path is through the NMOS pull-down network with 2 transistors in series. & $2.0\tau$ \\
        \cline{2-4}
        & AND & Implemented as a NAND gate followed by an inverter. Combines the delay of NAND 2.0$\tau$ with the delay of an inverter 1.0$\tau$. & $3.0\tau$ \\
        \cline{2-4}
        & NOR & Implemented with 2 PMOS transistors in series and 2 NMOS transistors in parallel. The critical path is through the PMOS pull-up network with 2 transistors in series. & $2.0\tau$ \\
        \cline{2-4}
        & OR & Implemented as a NOR gate followed by an inverter. Combines the delay of NOR 2.0$\tau$ with the delay of an inverter 1.0$\tau$. & $3.0\tau$ \\
        \cline{2-4}
        & XOR & As shown in Figure \ref{fig:cmos-binary-xor} the XOR gate is implemented using 4 transmission gates and 2 inverters. The critical path is a sequential layout of one inverter and one transmission gate with delays of $1.0\tau$ and $2.0\tau$ respectively. & $3.0\tau$ \\
        \hline
    \end{tabular}
    \caption{Propagation Delay Analysis for Binary Gates}
    \label{tab:gate-delay-reasoning}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{|c|l|p{9cm}|c|}
        \hline
        & \textbf{Gate} & \textbf{Propagation Delay Explanation} & \textbf{Delay} \\
        \hline
        \multirow{11}{*}{\rotatebox[origin=c]{90}{\textbf{Ternary CNFET}}} 
        & BUF & A simple buffer implementation serving as a pass-through circuit with minimal complexity. This represents the baseline switching time in CNFET technology. & $1.0\eta$ \\
        \cline{2-4}
        & NOT & Standard ternary inverter requiring more transistors than its binary counterpart. Implemented with 5 transistors to handle the three logic levels in ternary logic. The critical path involves multiple threshold-based transistor arrangements. & $1.6\eta$ \\
        \cline{2-4}
        & PTI & Positively Biased Inverter that selectively inverts only positive logic values. Requires specialised threshold detection circuitry with 6 transistors, resulting in a more complex critical path than the standard inverter. & $2.0\eta$ \\
        \cline{2-4}
        & NTI & Negatively Biased Inverter that selectively inverts only negative logic values. Similar in complexity to PTI, implemented with 6 transistors and specialised threshold detection. & $2.0\eta$ \\
        \cline{2-4}
        & NAND & Implements the "minimum with negation" function for ternary logic. Requires 10 transistors to handle the three-valued logic operation with appropriate thresholds. More complex than a standard inverter but with optimised transistor arrangement. & $3.0\eta$ \\
        \cline{2-4}
        & AND & Implements the minimum function (ternary AND) using 15 transistors. Typically constructed as a NAND followed by an inverter, resulting in increased delay compared to NAND. The critical path involves multiple threshold detection stages. & $4.6\eta$ \\
        \cline{2-4}
        & NOR & Implements "maximum with negation" for ternary logic values using 10 transistors. The critical path is more complex than NAND due to the OR-based operation in ternary logic, resulting in higher delay despite the same transistor count. & $5.0\eta$ \\
        \cline{2-4}
        & OR & Implements the maximum function (ternary OR) using 15 transistors. Typically constructed as a NOR followed by an inverter, with multiple threshold detection stages in the critical path. Has the highest delay among standard gates due to complexity. & $6.6\eta$ \\
        \cline{2-4}
        & XOR & Implements exclusive OR for ternary values using 18 transistors. Requires complex combination of logic elements to handle the three-valued inputs and outputs. The critical path includes multiple stages of threshold detection and switching. & $6.0\eta$ \\
        \cline{2-4}
        & CONS & Implements the consensus function in ternary logic with 55 transistors. This complex operation requires extensive circuitry but uses an optimised implementation to keep delay relatively low despite high transistor count. & $2.4\eta$ \\
        \cline{2-4}
        & ANY & Implements the "any" function in ternary logic. Design details not fully specified but the critical path optimisation allows for relatively low delay. & $2.4\eta$ \\
        \hline
    \end{tabular}
    \caption{Propagation Delay Analysis for Ternary CNFET Gates}
    \label{tab:ternary-gate-delay-reasoning}
\end{table}

\end{document}

% \begin{table}[h]
%     \centering
%         \begin{tabular}{|c|c|c|c|}
%         \hline
%         Gate & Base & Node Size (nm) & Delay (ps) \\
%         \hline
%         CNFET & Ternary & $11$ & $0.48$ \\
%         CNFET & Ternary & $7$ & $0.55$ \\
%         CNFET & Ternary & $45$ & $47$ \\
%         CMOS & Binary & $45$ & $162$ \\
%         CNFET & Ternary & $32$ & $3.11$ \\
%         CNFET & Ternary & $32$ & $2.79$ \\
%         CMOS & Binary & $32$ & $9.55$ \\
%         \hline
%         \end{tabular}
%     \centering
%     \caption{Propagation Delay of CNFET transistors and CMOS transistor pairs}
%     \label{fig:gate-prop-delay}
% \end{table}
